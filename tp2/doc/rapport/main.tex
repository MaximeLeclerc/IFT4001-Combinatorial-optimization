\documentclass[11pt]{article}
\usepackage[francais]{babel}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{color}
\usepackage{multirow}
\usepackage{tabu}

\usepgfplotslibrary{groupplots}

\setlength{\oddsidemargin}{-0,2in}
\topmargin -12,0mm
\textheight 22cm
\textwidth 17,8cm


\title{IFT-4001 (Hiver 2016) Projet d'exploration}
\date{24 avril 2016}
\author{Alexandre Cormier (111 101 150)\\Alexandre Picard-Lemieux (111 103 625)\\Patrick Côté (111 103 743)\\Vincent Beaudoin (111 103 778)}

\begin{document}

	\maketitle
	\newpage

	\section{Introduction}

		Utilisée depuis l'antiquité, la cryptographie sert à protéger des messages. Celle-ci se fait souvent à l'aide de secrets ou de clés. Cette cryptographie a principalement été utilisée à des fins militaires, commerciales ou simplement pour protéger la vie privée. L'opération de déchiffrer un message peut donc avoir des conséquences assez importantes sur la vie des gens, car ces informations peuvent mener à des actions destructives ou créatives.\\

		L'optimisation combinatoire est une branche de l'informatique et des mathématiques appliquées. C'est la recherche d'une solution au coût minimal d'un problème dont l'espace des solutions est discret. Nous ferons une étude de la viabilité de la programmation par contraintes pour attaquer la cryptographie classique par substitution.\\

	\section{Description du problème}

		Le chiffrement par substitution est une façon de cacher un message en remplaçant chaque lettre par une autre. On parle de substutition monoalphabétique lorsque qu'une lettre est toujours remplacée par la même autre lettre. Autrement, on parle de substitution polyalphabétique.\\

		Un exemple de chiffrement par substitution monoalphabétique est le chiffre de César. Pour ce chiffre, on associe à chaque lettre sa position dans l'alphabet, commençant par 0. La clé est une lettre et chaque lettre du message est décalée d'un nombre de positions correspondant à la clé. Par exemple, le message ABC chiffré avec la clé B devient BCD. Les calculs de décalage se font en modulo 26, tel que XYZ chiffré avec la même clé devient YZA.\\

		Le chiffre de vigenère est un exemple de chiffrement par substitution polyalphabétique. La clé est composée d'une ou plusieurs lettres et le message est placé divisé en partie de la même longueur que la clé. Si les différentes parties du message sont placées l'une en-dessous de l'autre, il suffit d'appliquer le chiffre de César à chaque colonne $i$ avec la $i^{\grave{e}me}$ lettre de la clé. Par exemple, le message ABCD chiffré avec la clé BC devient BDDF.\\

		La substition est toujours une composante à la base de la cryptographie moderne, mais ces méthodes de chiffrement simples ne sont plus utilisées comme systèmes cryptographiques à part entière puisqu'elles sont vulnérables à différentes attaques. Il est possible, notamment, d'analyser la fréquence relative des lettres dans le message chiffré et comparer avec la fréquence relative des lettres dans la langue du message d'origine pour trouver les clés les plus probables.\\

		Dans le cadre de ce projet, nous étudierons une méthode alternative, utilisant la programmation par contrainte, pour retrouver la clé de tels chiffrements à partir du message chiffré. Il est évidemment impossible pour un programme automatisé de trouver la clé de façon certaine, car il n'y a pas nécessairement moyen de reconnaître le message d'origine lorsque la bonne clé est trouvée. Par contre, nous pourrons ordonner les clés les plus probables selon, notamment, la fréquence relative de chaque lettre dans le message déchiffré.\\

		L'objectif ici est d'étudier la viabilité d'une telle approche, par contrainte, pour l'attaque du chiffrement par substitution. Nous étudierons l'efficacité de l'approche selon la longueur du message et, dans le cas du chiffre de Vigenère, de la longueur de la clé.\\

		Par exemple, en prenant le message encrypté LXFOPVEFRNHR, le solveur doit trouver que la clé la plus probable est LEMON et que le texte original est ATTACKATDAWN. L'implémentation utilisée utilisera les fréquences des lettres trouvées d'une langue donnée.\footnote{Wikipedia, [En ligne]. \url{https://en.wikipedia.org/wiki/Letter\_frequency} (Page consultée le 3 avril 2016)} Cette implémentation sera donc plus efficace si la chaine est longue et si elle utilise des vrais mots de la langue choisie.\\

	\section{Approche proposée}

		La façon la plus préconisée pour attaquer le chiffrement de Vigenère est l'analyse de fréquences. C'est aussi l'approche que nous proposons, seulement elle sera implémentée à l'aide de la programmation par contraintes. Il s'agit de calculer la fréquence de chaque lettre dans le message déchiffré et de comparer avec la fréquence de chaque lettre dans la langue ciblée.

		\subsection{Modèle de base}

			Le modèle présenté ici est le premier modèle conçu, purement théorique, avant toute tentative de l'implémenter dans le solveur de contraintes.

			\subsubsection{Modèlisation du chiffrement de Vigenère}

				Soit:
				\begin{itemize}
					\item $n$ la longueur de la chaîne à déchiffrer;
					\item $k$ la longueur de la clé;
					\item $l$ le nombre de lettres dans l'alphabet de la langue ciblée;
					\item $\mathbb{N}_n$ l'ensemble des nombres naturels modulo $n$;
					\item $\mathbb{Z}_n$ l'ensemble des nombres naturels modulo $n$ ainsi que leur opposé.
				\end{itemize}

				\bigskip

				On a donc, $(\forall i : 1 \leq i \leq n)$:
				\begin{itemize}
					\item $C_i \in \mathbb{N}_l$ la $i^{\grave{e}me}$ lettre de la chaîne chiffrée;
					\item $P_i \in \mathbb{N}_l$ la $i^{\grave{e}me}$ lettre de la chaîne déchiffrée.
				\end{itemize}

				\bigskip

				Et aussi, $(\forall i : 1 \leq i \leq k)$:
				\begin{itemize}
					\item $K_i \in \mathbb{N}_l$ la $i^{\grave{e}me}$ lettre de la clé.
				\end{itemize}

				\bigskip

				On a la contrainte suivante:

				\begin{equation} \label{eq:1}
				P_i + K_{i \bmod k} \equiv C_i \mod l \qquad \forall i : 1 \leq i \leq n
				\end{equation}

			\subsubsection{Modélisation de l'analyse de fréquences}

				Soit, $(\forall i : 1 \leq i \leq l)$:
				\begin{itemize}
					\item $f_i$ la fréquence de la $i^{\grave{e}me}$ lettre de l'alphabet dans la langue ciblée;
					\item $Z_i \in \mathbb{N}_{n+1}$ le nombre de fois qu'apparaît la $i^{\grave{e}me}$ lettre de l'alphabet dans le message déchiffré.
				\end{itemize}

				\bigskip

				Et soit la contrainte suivante:
				\begin{equation} \label{eq:2}
					Z_i = Count(i, P) \qquad \forall i : 1 \leq i \leq l
				\end{equation}

				Nous devons avoir une mesure d'évaluation des solutions trouvées. La distance euclidienne entre la fréquence des lettres dans le message déchiffré et celle dans la langue ciblée est un choix intuitif. La fonction objectif est donc la suivante:
				\begin{equation} \label{eq:3}
					\min \sqrt{\sum\limits_{i=1}^n (\frac{Z_i}{n} - f_i)^2}
				\end{equation}
				ou de façon équivalente:
				\begin{equation} \label{eq:4}
					\min \sum\limits_{i=1}^n (\frac{Z_i}{n} - f_i)^2
				\end{equation}

        \subsection{Modèle implémenté}

			Le modèle de base est simple, mais il présente quelques défis à l'implémentation\footnote{Nous avons fait l'implémentation avec le solveur Choco.}, notamment en lien avec les nombres réels pour les fréquences.
			On doit aussi ajouter quelques variables et contraintes intermédiaires.

			\subsubsection{Variables et contraintes intermédiaires}

				Pour la modélisation du (dé)chiffrement, il faut ajouter des variables supplémentaires, $(\forall i : 1 \leq i \leq n)$. Soit donc:
				\begin{itemize}
					\item $I_i \in \mathbb{N}_{2l-1}$ la $i^{\grave{e}me}$ lettre du texte intermédiaire.
				\end{itemize}

				\bigskip

				La contrainte \ref{eq:1} est alors séparée en deux contraintes distinctes:
				\begin{equation} \label{eq:5}
					P_i + K_{i \bmod k} = I_i \qquad \forall i : 1 \leq i \leq n
				\end{equation}
				\begin{equation} \label{eq:6}
					I_i \bmod l = C_i \qquad \forall i : 1 \leq i \leq n
				\end{equation}

				De plus, il faut séparer la fonction objectif en plusieurs variables et contraintes. On introduit donc les variables intermédiaires suivantes, $(\forall i : 1 \leq i \leq l)$:
				\begin{itemize}
					\item $F_i \in [0,1]$ la fréquence de la $i^{\grave{e}me}$ lettre de l'alphabet dans le message déchiffré;
					\item $D_i \in [-1,1]$ la différence entre la fréquence de la $i^{\grave{e}me}$ lettre dans le message déchiffré et celle dans la langue ciblée;
					\item $A_i \in [0,1]$ cette différence élevée à la puissance 2.
				\end{itemize}

				\bigskip

				Il faut aussi ajouter une variable à minimiser:
				\begin{itemize}
					\item $S \in [0,l]$ la somme des différences de fréquences au carré.
				\end{itemize}

				\bigskip

				Pour lier ces variables ensemble, il faut de nouvelles contraintes:
				\begin{equation} \label{eq:7}
					F_i = \frac{Z_i}{n} \qquad \forall i : 1 \leq i \leq l
				\end{equation}
				\begin{equation} \label{eq:8}
					D_i = F_i - f_i \qquad \forall i : 1 \leq i \leq l
				\end{equation}
				\begin{equation} \label{eq:9}
					A_i = D_i^2 \qquad \forall i : 1 \leq i \leq l
				\end{equation}
				\begin{equation} \label{eq:10}
					S = \sum\limits_{i = 1}^n A_i
				\end{equation}

			\subsubsection{Gestion des nombres réels}

				Pour simplifier l'implémentation avec le solveur, nous avons adopté une stratégie pour les transformer en entiers.
				Nous avons choisi le niveau de précision désiré, selon la précision des fréquences dont nous disposons\footnote{Wikipedia, [En ligne]. \url{https://en.wikipedia.org/wiki/Letter_frequency} (Page consultée le 24 avril 2016)} pour les langues cibles.

				Soit donc:
				\begin{itemize}
					\item $p$ la précision choisie en nombre de décimales.
				\end{itemize}

				\bigskip

				On applique donc la modification suivante aux fréquences relatives des lettres de la langue ciblée, $(\forall i : 1 \leq i \leq l)$:
				\begin{equation} \label{eq:11}
					f_i = f_i * 10^p \qquad \forall i : 1 \leq i \leq l
				\end{equation}

				On doit aussi multiplier le compte des lettres, alors on introduit des variables intermédiaires, $(\forall i : 1 \leq i \leq l)$:
				\begin{itemize}
					\item $M_i \in \mathbb{N}_{10^p(n+1)}$ le nombre de fois qu'apparaît la $i^{\grave{e}me}$ lettre de l'alphabet dans le message déchiffré, multiplié par $10^p$.
				\end{itemize}

				\bigskip

				On ajoute donc la contrainte suivante:
				\begin{equation} \label{eq:12}
					M_i = Z_i * 10^p \qquad \forall i : 1 \leq i \leq l
				\end{equation}

				Et la contrainte (\ref{eq:7}) devient plutôt:
				\begin{equation} \label{eq:13}
					F_i = \frac{M_i}{n} \qquad \forall i : 1 \leq i \leq l
				\end{equation}

				Puisqu'on se retrouve ainsi avec de grands nombres, il faut se méfier du dépassement d'entiers (\emph{integer overflow}). On peut donc simplifier la fonction objectif en remplaçant le carré par la valeur absolue:
				\begin{equation} \label{eq:14}
					\min \sum\limits_{i=1}^n |\frac{Z_i}{n} - f_i|
				\end{equation}
				Cette nouvelle fonction objectif n'est pas équivalente à la première, mais elle permet d'éviter des problèmes et nos résultats sont même meilleurs avec celle-ci que nos résultats préliminaires avec la distance euclidienne.

				\bigskip

				On doit aussi modifier le domaine des variables reliées à la fréquence. Soit, $(\forall i : 1 \leq i \leq l)$:
				\begin{itemize}
					\item $F_i \in \mathbb{N}_{10^p + 1}$ la fréquence de la $i^{\grave{e}me}$ lettre de l'alphabet dans le message déchiffré;
					\item $D_i \in \mathbb{Z}_{10^p + 1}$ la différence entre la fréquence de la $i^{\grave{e}me}$ lettre dans le message déchiffré et celle dans la langue ciblée;
					\item $A_i \in \mathbb{N}_{10^p + 1}$ la valeur absolue de cette différence.
				\end{itemize}

				\bigskip

				Et de même pour la variable à minimiser:
				\begin{itemize}
					\item $S \in \mathbb{N}_{l(10^p + 1)}$ la somme des valeurs absolues des différences de fréquences.
				\end{itemize}

				\bigskip

				Finalement, la division de la contrainte \ref{eq:7} doit maintenant être une division entière.

				\bigskip

				Au final, nous avons des listes de $n$, $k$ et $l$ variables. Le nombre de variables est donc borné par $\theta(n + k + l)$.

				\bigskip

				Chaque variable dans les listes de $n$ ont $l$ ou $2l - 1$ valeurs possibles.

				Chaque variable dans les listes de $k$ ont $l$ valeurs possibles.

				Chaque variable dans les listes de $l$ ont $n+1$, $10^p(n+1)$ ou $2(10^p(n+1))$ valeurs possibles.

				Le nombre de valeurs est donc borné par $\theta(nl + kl + l(10^pn))$. $p$ peut toutefois être considéré comme une constante (nous utilisons 5) et donc on obtient $\theta(l(n + k))$.

				\bigskip

				Nous avons $n$ contraintes de type (\ref{eq:5}) et (\ref{eq:6}), $l$ contraintes de type (\ref{eq:2}), (\ref{eq:8}), (\ref{eq:9}), (\ref{eq:12}) et (\ref{eq:13}) ainsi qu'une contrainte de type (\ref{eq:10}). Le nombre de contraintes est donc borné par $\theta(n + l)$.

		\subsection{Amélioration des heuristiques}
			Pour tenter d'améliorer les performances du solver, nous avons créé une nouvelle heuristique adapté au modèle.
			Cette nouvelle heurisitque comprend le choix de la variable ainsi que le choix de la valeur.
			Elle fait tout ses calculs lors de son initialisation et elle retourne les résultats de ses calculs lors d'une requète par le solveur.

			\subsubsection{Stratégie pour choisir la variable}
				L'heuristique se contruit avec le message chiffré $C$ et la longueur de la clé à trouver $k$ comme paramètres.
				Ensuite, elle place toutes les indices des caractères $c \in C$ dans une liste, dans l'ordre de celui qui à le plus d'occurences pour l'une des $k$ sous-chaînes.
				Ces sous-chaînes commencent aux différentes indices $[0...k-1]$ dans $C$ et elles contienent toutes les caractères à des bonds de $k$.
				Nous séparons en sous-chaînes, puisqu'on sait que deux caractères identiques dans la chaîne chiffrée resteront identiques s'ils sont à une distance égale à $k$.
				De cette façon, la variable associé au caractère le plus fréquent est aussi celle qui assigne le plus de variable à une valeur (toutes les autres occurences du caractère).
				Lors de la requète d'une variable à choisir par le solveur, l'heurisitque ne fait que retourné les indices de sa liste dans l'ordre.

				Voyons deux examples avec $C = "ABABBCACBC"$
				\begin{center}
					\begin{tabular}{| c | c | c | c | c | c | c | c | c | c |}
						\hline
						\textbf{A} & \textbf{B} & \textbf{A} & \textbf{B} & \textbf{B} & \textbf{C} & \textbf{A} & \textbf{C} & \textbf{B} & \textbf{C} \\
						\hline
						0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
						\hline
					\end{tabular}
				\end{center}

				Example avec $k=1$ \\
				Dans ce cas, on a une seule sous-chaîne $S$ qui contient "ABABBCACBC"
				On trouve alors que le caractère le plus présent est 'B' avec 4 occurences.
				On place finalement le premier indice de B dans la sous-chaîne $S$, soit $1$, dans la liste.
				Les caractères restants 'A' et 'C' ont la même fréquence dans $S$, alors on place leur premier indice dans la liste.
				La liste final est donc: [1,0,5] qui représente: ['B','A','C'] \\

				Example avec $k=2$
				Maintenant, on a deux sous-chaîne à considérer. \\
				$S_1 = "AABAB"$ les caractères aux indices pairs. \\
				$S_2 = "BBCCC"$ les caractères aux indices impairs. \\
				Pour $S_1$, le caractère le plus fréquent est 'A' avec un $3$ occurences. \\
				Pour $S_2$, il s'agit plutôt de 'C' avec 3 occurences.
				On compare maintenant les caractères retournées par les sous-chaînes et on prend celui qui était le plus fréquent dans sa sous-chaînes.
				En cas, d'égalité, on choisi le premier caractère trouvé, soit 'A' dans cet example.
				On ajoute à la liste le premier indice de ce caractère dans la chaîne de départ.
				Après toutes les itération on obtient [0,5,4,1] qui représente: [ 'A', 'C', 'B' de $S_1$, 'B' de $S_2$]

				On remarque ici que pour une même chaîne chiffrée de départ, on retourne un indice différent selon la longueur de la clé. \\

			\subsubsection{Stratégie pour choisir la valeur}
				Nous avons déterminé les lettres les plus utilité pour un language.
				Par example, pour l'anglais, on à dans l'ordre les lettres suivantes: \\
				e,t,a,o,i,n,s,h,r,d,l,c,u,m,w,f,g,y,p,b,v,k,j,x,q,z \\
				Cette infomation est passé en paramètre pour construire la stratégie.
				Elle s'en servira pour créer une liste avec les positions de chaque lettres dans l'alphabet dans le même ordre.
				Il s'agit alors d'une heuristique statique puisqu'elle ne fait que retouner les indices dans un ordre précis.
				On commence donc par retourner 4 pour la lettre 'e', suivit de 19 pour 't' et ainsi de suite.

		\subsection{Recherche des m meilleures solutions}
			Dans la majorité des cas, on problème d'optimisation combinatoire demande une solution valide, la meilleure solution ou toutes les solutions.
			Dans notre cas, seulement la meilleure solution n'est pas suffisante, puisqu'il n'est pas assuré que la solution la plus probable du point de vue de l'analyse de fréquence sera réellement la solution qui mène au bon message en clair.
			En effet, certains messages peuvent ne pas respecter les fréquences relatives typiques des lettres de la langue dans laquelle il est écrit.
			Trouver toutes les solutions n'est pas n'ont plus envisageable, puisqu'il serait beaucoup trop long de toutes les calculer et qu'au final, ce serait même moins efficace qu'une attaque par force brute traditionnelle.

			Ce que l'on veut donc, c'est obtenir une liste des $m$ solutions les plus probables, pour qu'elles soit ensuite analysées par un humain ou un autre programme.
			Le choix de $m$ est important: s'il est trop petit, la bonne solution ne sera pas trouvée; s'il est trop grand, la recherche sera beaucoup trop longue.
			Pour être efficace, $m$ doit varier selon la longueur de la clé et la longueur de l'alphabet de la langue cible, puisque ce sont les paramètre qui font varier le nombre total de solutions.
			Le nombre total de solutions est $l^k$. Le nombre de solutions à retourner que nous avons choisi est $(\frac{l}{4})^k$.
			Par contre, pour trouver toutes ces solutions, plus de $(\frac{l}{4})^k$ solutions doivent être explorées.


    \section{Protocole d'expérimentation}
		Nous avons choisi de faire des tests  sur des instances de différentes
		longueurs de message et de clé, des messages qui respectent bien la
		distribution de lettres anglaises, d'autre qui ne la respectent pas. Les
		métriques que nous allons observer durant les expérimentations sont le
		temps de réponse, le nombre de retours arrière, ainsi que le nombre de
		solutions trouver. \\

		La première instance est une instance qui est considérée comme étant un message
		long ayant une clé de longueur 4 et qui devrait avoir une distribution correcte de la fréquence des lettres. \\
		Voici le texte brut : {\tiny FRIEN DSROM ANSCO UNTRY MENLE NDMEY OUREA RSICO METOB URYCA ESARN OTTOP RAISE HIMTH EEVIL THATM ENDOL IVESA FTERT HEMTH EGOOD ISOFT INTER REDWI THTHE IRBON ESSOL ETITB EWITH CAESA RTHEN OBLEB RUTUS HATHT OLDYO UCAES ARWAS AMBIT IOUSI FITWE RESOI TWASA GRIEV OUSFA ULTAN DGRIE VOUSL YHATH CAESA RANSW ERDIT HEREU NDERL EAVEO FBRUT USAND THERE STFOR BRUTU SISAN HONOU RABLE MANSO ARETH EYALL ALLHO NOURA BLEME NCOME ITOSP EAKIN CAESA RSFUN ERAL} \\
		\\ Voici le texte encrypté : {\tiny YKBXG WLKHF TGLVH NGMKR FXGEX GWFXR HNKXT KLBVH FXMHU NKRVT XLTKG HMMHI KTBLX ABFMA XXOBE MATMF XGWHE BOXLT YMXKM AXFMA XZHHW BLHYM BGMXK KXWPB MAMAX BKUHG XLLHE XMBMU XPBMA VTXLT KMAXG HUEXU KNMNL ATMAM HEWRH NVTXL TKPTL TFUBM BHNLB YBMPX KXLHB MPTLT ZKBXO HNLYT NEMTG WZKBX OHNLE RATMA VTXLT KTGLP XKWBM AXKXN GWXKE XTOXH YUKNM NLTGW MAXKX LMYHK UKNMN LBLTG AHGHN KTUEX FTGLH TKXMA XRTEE TEEAH GHNKT UEXFX GVHFX BMHLI XTDBG VTXLT KLYNG XKTE} \\


		La deuxième instance est une instance qui est considérée comme étant un message
		d'une courte longueur ayant une clé de longueur 1 et qui a une bonne distribution de la fréquence des lettres.
		De plus, cette instance va être réutilisée pour faire des tests avec des clés de longueur 2,3,4,5.
		\\ Voici le texte brut : {\tiny GENIUS WITHOUT EDUCATION IS LIKE SILVER IN THE MINE} \\

		La troisième instance est une instance qui est considérée comme un long message ayant une
		très bonne distribution de la fréquence des lettres que nous avons testées sur une clé de 1 à 4.
		\\ Voici le texte brut : {\tiny HEREUPON LEGRAND AROSE WITH A GRAVE AND STATELY AIR AND BROUGHT ME THE BEETLE FROM A GLASS CASE IN WHICH IT WAS ENCLOSED IT WAS A BEAUTIFUL SCARABAEUS AND AT THAT TIME UNKNOWN TO NATURALISTS OF COURSE A GREAT PRIZE IN A SCIENTIFIC POINT OF VIEW THERE WERE TWO ROUND BLACK SPOTS NEAR ONE EXTREMITY OF THE BACK AND A LONG ONE NEAR THE OTHER THE SCALES WERE EXCEEDINGLY HARD AND GLOSSY WITH ALL THE APPEARANCE OF BURNISHED GOLD THE WEIGHT OF THE INSECT WAS VERY REMARKABLE AND TAKING ALL THINGS INTO CONSIDERATION I COULD HARDLY BLAME JUPITER FOR HIS OPINION RESPECTING IT}\\

		La quatrième instance est une instance ayant une longueur courte et qui
		ne respect pas très bien la distribution des lettres. Nous l'avons testé
		sur une clé de longueur 1. \\ Voici le texte brut : {\tiny ZJXQKB} \\

	\newpage
    \section{Résultats}

 		Voici les résultats sans l'heuristique que nous avons créée:
		\begin{center}
			\begin{tabular}{| c | c | c | c | c |}
			\hline
			\textbf{Instances} & \multicolumn{4}{ c |}{\textbf{Résultats}}  \\
			\cline{2-5}
			& \textbf{Longueur} & \textbf{Retour} & \textbf{Temps} & \textbf{Solutions}\\
			& \textbf{clé} & \textbf{arrière} & \textbf{de réponse} & \textbf{(trouvées/retournées)}\\
			\hline

			\multirow{4}{*}{1} & 1 & 51 & 0.038 secondes & 15/6 \\ \cline{2-5}
							   & 2 & 1 361 & 0.432 secondes & 163/36 \\ \cline{2-5}
							   & 3 & 32,259 & 7.134 secondes & 1 139/216 \\ \cline{2-5}
							   & 4 & 648,563 & 105.211 secondes & 10 316/1 296 \\ \hline
			\multirow{5}{*}{2} & 1 & 55 & 0.007 secondes & 19/6 \\ \cline{2-5}
							   & 2 & 1369 & 0.306 secondes & 172/36 \\ \cline{2-5}
							   & 3 & 68 345 & 1.944 secondes & 1 576/216 \\ \cline{2-5}
							   & 4 & 6 607 263 & 114.837 secondes & 11 646/1 296 \\ \cline{2-5}
							   & 5 & 1 611 566 903 & 6h 49m 47s & 292/{\color{red}{10}} \\ \hline
			\multirow{4}{*}{3} & 1 & 51 & 0.047 secondes & 15/6 \\ \cline{2-5}
							   & 2 & 1 345 & 0.535 secondes & 155/36 \\ \cline{2-5}
							   & 3 & 32 091 & 8.419 secondes & 1 372/216 \\ \cline{2-5}
							   & 4 & 648 031 & 134.406 secondes & 10 309/1 296 \\ \hline
			\multirow{4}{*}{4} & 1 & 63 & 0.034 secondes & 15/6 \\ \cline{2-5}
							   & 2 & 4 297 & 0.251 secondes & 166/36 \\ \cline{2-5}
							   & 3 & 263 683 & 3.301 secondes & 1 497/216 \\ \cline{2-5}
							   & 4 & 3 097 089 & 25.853 secondes & 13 062/1 296 \\ \hline
			\end{tabular}
		\end{center}


		Voici les résultats avec l'heuristique que nous avons créée:
		\begin{center}
			\begin{tabular}{| c | c | c | c | c |}
			\hline
			\textbf{Instances} & \multicolumn{4}{ c |}{\textbf{Résultats}}  \\
			\cline{2-5}
			& \textbf{Longueur} & \textbf{Retour} & \textbf{Temps} & \textbf{Solutions}\\
			& \textbf{clé} & \textbf{arrière} & \textbf{de réponse} & \textbf{(trouvées/retournées)}\\
			\hline

			\multirow{4}{*}{1} & 1 & 51 & 0.041 secondes & 10/6 \\ \cline{2-5}
							   & 2 & 1 351 & 0.502 secondes & 69/36 \\ \cline{2-5}
							   & 3 & 35 151 & 9.579 secondes & 542/216 \\ \cline{2-5}
							   & 4 & 913 951 & 187.582 secondes & 3 947/1 296 \\ \hline
			\multirow{5}{*}{2} & 1 & 51 & 0.029 secondes & 8/6 \\ \cline{2-5}
							   & 2 & 1 351 & 0.073 secondes & 98/36 \\ \cline{2-5}
							   & 3 & 35 151 & 1.266 secondes & 663/216 \\ \cline{2-5}
							   & 4 & 913 951 & 26.016 secondes & 5 920/1 296 \\ \cline{2-5}
							   & 5 & 23 575 363 & 548,744 secondes & 44 471/7 776 \\ \hline
			\multirow{4}{*}{3} & 1 & 51 & 0.173 secondes & 12/6 \\ \cline{2-5}
							   & 2 & 1 351 & 0.585 secondes & 67/36 \\ \cline{2-5}
							   & 3 & 35 151 & 11.192 secondes & 499/216 \\ \cline{2-5}
							   & 4 & 913 951 & 209.476 secondes & 5 470/1 296 \\ \hline
			\multirow{4}{*}{4} & 1 & 51 & 0.042 secondes & 10/6 \\ \cline{2-5}
							   & 2 & 1 351 & 0.021 secondes & 102/36 \\ \cline{2-5}
							   & 3 & 35 151 & 0.437 secondes & 774/216 \\ \cline{2-5}
							   & 4 & 240 687 & 2.853 secondes & 7 105/1 296 \\ \hline

			\end{tabular}
		\end{center}

		Il est important de noter que le test de l'instance 2 avec une clé de 5 lettres a été modifié pour ne retourner que les 10 meilleures solutions lorsque nous l'avons exécuté sans notre heuristique, en raison du temps d'exécution très élevé. C'est indiqué en rouge dans les tableaux ci-dessus et en pointillés dans la figure \ref{fig:1} ci-dessous.

		Il est aussi important de noter que, pour tous ces tests, la fréquence relative des lettres est assez près de la fréquence relative typique de l'anglais pour que le solveur trouve la bonne solution parmi celles retournées, à l'exception des tests de l'instance 4 et du test mentionné précédemment pour lequel on a spécifié manuellement de ne retourner que les 10 meilleures solutions.

		\begin{figure}[!htbp] \label{fig:1}
		    \centering
			{\renewcommand{\arraystretch}{3}
				\begin{tabu}{X[c]X[c]}
					\textbf{Instance 1}\newline
					\begin{tikzpicture}
						\begin{axis}[
							axis lines = left,
							xlabel = Longueur de la clé, xmin = 0, xmax = 5.5, xtick = {1,2,3,4,5},
							ylabel = Temps (secondes), ymax = 30000, ymode = log, ymajorgrids = true,
							legend pos = north west,
							grid style = dashed
						]
							\addplot [color=red, mark=*] coordinates {(1,0.038)(2,0.432)(3,7.134)(4,105.211)};
							\addplot [color=blue, mark=*] coordinates {(1,0.041)(2,0.502)(3,9.579)(4,187.582)};
							\addlegendentry{domOverWDeg}
							\addlegendentry{heuristique personnalisée}
						\end{axis}
					\end{tikzpicture}
					&
					\textbf{Instance 2}\newline
					\begin{tikzpicture}
						\begin{axis}[
							axis lines = left,
							xlabel = Longueur de la clé, xmin = 0, xmax = 5.5, xtick = {1,2,3,4,5},
							ylabel = Temps (secondes), ymax = 30000, ymode = log, ymajorgrids = true,
							legend pos = north west,
							grid style = dashed
						]
							\addplot [color=red, mark=*] coordinates {(1,0.007)(2,0.306)(3,1.944)(4,114.837)};
							\addplot [color=blue, mark=*] coordinates {(1,0.029)(2,0.073)(3,1.266)(4,26.016)(5,548.744)};
							\addplot [color=red, mark=*, dashed] coordinates {(4,114.837)(5,23391.998)};
							\addlegendentry{domOverWDeg}
							\addlegendentry{heuristique personnalisée}
						\end{axis}
					\end{tikzpicture}
					\\
					\textbf{Instance 3}\newline
					\begin{tikzpicture}
						\begin{axis}[
							axis lines = left,
							xlabel = Longueur de la clé, xmin = 0, xmax = 5.5, xtick = {1,2,3,4,5},
							ylabel = Temps (secondes), ymax = 30000, ymode = log, ymajorgrids = true,
							legend pos = north west,
							grid style = dashed
						]
							\addplot [color=red, mark=*] coordinates {(1,0.047)(2,0.535)(3,8.419)(4,134.406)};
							\addplot [color=blue, mark=*] coordinates {(1,0.173)(2,0.585)(3,11.192)(4,209.476)};
							\addlegendentry{domOverWDeg}
							\addlegendentry{heuristique personnalisée}
						\end{axis}
					\end{tikzpicture}
					&
					\textbf{Instance 4}\newline
					\begin{tikzpicture}
						\begin{axis}[
							axis lines = left,
							xlabel = Longueur de la clé, xmin = 0, xmax = 5.5, xtick = {1,2,3,4,5},
							ylabel = Temps (secondes), ymax = 30000, ymode = log, ymajorgrids = true,
							legend pos = north west,
							grid style = dashed
						]
							\addplot [color=red, mark=*] coordinates {(1,0.034)(2,0.251)(3,3.301)(4,25.853)};
							\addplot [color=blue, mark=*] coordinates {(1,0.042)(2,0.021)(3,0.437)(4,2.853)};
							\addlegendentry{domOverWDeg}
							\addlegendentry{heuristique personnalisée}
						\end{axis}
					\end{tikzpicture}
				\end{tabu}
			}

			\caption{Différence entre l'heuristique par défaut (domOverWDeg) et notre heuristique personnalisée}
		\end{figure}


	\section{Discussion}
		En observant les figures ci-dessus, on peut voir que notre modèle fonctionne bien pour des textes cryptés avec une clé inférieure ou égale à 5.
		Par contre, on peut voir que lorsque nous utilisons l'heuristique par défaut avec l'instance 2, le temps de résolutions augmente de façon exponentiellement selon la longueur de la clé.
		Par contre, nous pouvons voir ci-dessus, que lorsque nous utilisons notre heuristique, le temps de résolutions est diminue très considérablement le temps de résolution. Nous avons réussi à faire
		passer le temps de résolution de presque 7 heures à 9 minutes. Cependant, l'heuristique n'est pas totalement parfaite.
		Lorsque l'on regarde la figure de l'instance 1 et 4, nous voyons que l'heuristique par défaut fait un meilleur travail que lui que nous avons créé.
		De plus, cela nous a permis de trouver des limitations telles que lorsque le message est plus court et ainsi que le langage est non formel.

	\section{Conclusion}

		Dans le cadre de ce travail, nous avons attaqué la cryptographie classique par substitution à l'aide de la programmation par contrainte. Pour faire cela, nous avons fait un modèle que nous avons implémenté à l'aide de « Choco ». L'expérimentation a été un succès et nous avons résolu des problèmes simples de cryptographie. Par contre, nous avons vite réalisé que la programmation par contrainte ne serait pas bien adaptée pour régler des problèmes plus complexes.\\

		Il aurait été intéressant de tester différents types de cryptographie pour pouvoir comparer l'efficacité de ceux-ci.\\

\end{document}
